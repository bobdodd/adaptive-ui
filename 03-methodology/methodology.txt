Methodology
Method Selection
Based upon experience in the Accessibility Research Unit at Teesside University, and from the text of papers listed in the bibliography of this thesis, the general approach to research within the accessibility discipline is to begin from a specific physical or cognitive impairment, and a social context; this involves either investigating the effect of the impairment upon a given context and vice versa, or investigating adjustments and alternatives to the context in order to better serve the impaired person. One example of the latter approach is Ramloll and Brewster's (2002)  work on augmenting tactile diagrams with spatial non-speech sounds; Augmentation and associated adaptation formed the initial approach taken to the research for this Ph.D.
The problem that very quickly arose when taking this approach was in relation to the selection of impairments to consider. Having continued from a Master's level analysis of the problems faced by mobile phone users with Multiple Sclerosis (a disease of the central nervous system) the intention was to consider a range of potential improvements to the interaction modalities within the user interface of mobile phones. The intention was also to consider those potential adjustments against a broader range of impairment, with a view towards the concept of universal accessibility. This meant that two different questions were to be asked of each interaction modality: 
 	Q1: How well does the modality support a user with Multiple Sclerosis?
	Q2: Who else may be supported by that solution?
The method one would expect to follow for question (Q1), is the established general approach of: 
   a)	Construct a user model of the person and the impairment(s) under investigation for the chosen operating context.
   b) 	Validate the fidelity of the model against the selected test users.
   c)	Identify representative activities for the test users that would be impacted by their impairments in the given context.
   d) 	Identify quantitative and/or qualitative performance metrics related to the activities.
   e) 	Evaluate user performance for each activity against the given metrics.
   f)	 Perform a statistical analysis on the results.
   g)	 Reflect upon the implications of the results in the broader context of accessibility.
Question (Q2) is more problematic given that the breadth of the user model must entail all of the impairments under consideration, and that a larger model needs to be validated for fidelity. Depending upon the breadth chosen, such validation has practical limitations in terms of access to sufficient real users for the validation to be statistically meaningful. 
When the goal is universal access, the breadth, the coupling between, and the variation in severity of, physical and cognitive impairment make formal validation of such models entirely impractical; even if such problems could be addressed, the appropriateness of the representative tasks to be undertaken across such a diverse range of users, and the associated metrics, would also need to be addressed.
The attempt to address the issues surrounding question (Q2), and  identification of appropriate methods to answer it, became a focal point within the research. In essence, the research process followed the maxim: if the problem is too difficult to solve, then try solving other, closely related problems within the same ontology, and see if it helps change your perspective on the initial problem.
A Systems Approach
Consideration of  question (Q2) above, "Who else may also use that solution?" quickly identified a number of independent but related problem domains relating to the user, the device used to interact with the user, and the solution represented by its interaction modalities that required analysis. The relationships between those problem domains became the basis for much of the Ph.D. thesis, repeated here for convenience:
1.3.1 	Accessibility is the outcome of the encounter between an entity’s capacity to interact and its users physical and cognitive capabilities with capacity, capability, and accessibility all expressed as measurable and quantitative properties.
The purpose of the research consequently became an attempt to express that encounter in a measurable and quantitative manner such that the question, "Who else may use the solution?" becomes potentially answerable. In doing so, the research stepped away from  experimental evaluation of real users performing practical activities, to an investigation of meta-models of capability, capacity, and content, and that led to an entirely different research approach based on a systems analyst's view of accessibility.
Stepping away from an experimental, testable method of analysing specific solutions for specific users in favour of searching for a meta-model that describes the general case of interaction required a reappraisal of the research method in terms of process, the work products, and the evaluation criteria applied.
Given that the research was now perceived to be a modelling problem in multiple ontologies, the natural choice to support that modelling process was systems analysis,together with a consideration of appropriate metrics for evaluation of the usefulness of the resulting work products.
The chosen starting point for this systems analysis was the Shlaer-Mellor Object Oriented Analysis and Design method.
Adopting Shlaer-Mellor Semantics
Any number of systems analysis methods could be used as the starting point to analyse related ontologies, ranging from the older structured analysis and design methods of the 1970s and 1980s to later object oriented methods. The method chosen, Shlaer-Mellor, is one of the earlier object oriented methods, published in two volumes between 1988 and 1992. In selecting Shlaer-Mellor, a number of factors relating to the process, to the notation of the method, and to practicalities of its use were considered.
Experience
Personal experience with the Shlaer-Mellor method played a significant part in the selection of Shlaer-Mellor as the starting point for method selection. This research builds on a software career largely based on the use of Shlaer-Mellor, with experience dating back as far as 1989 with significant experience on major projects during the 1990s. That experience removed the learning curve, and de-risked the method selection in that the limitations of the method were already well understood.
Stability
 Given a definition of a method as:
	Method is process plus notation
then Shlaer-Mellor is one of the oldest, most mature object oriented analysis methods still in commercial use today. During the period of this research it has been subsumed into the marketing effort surrounding the Unified Modelling Language (UML) gaining an alternative graphical style and a new name: Executable UML (Mellor and Balcer, 2002 and  Raistrick et al, 2004) and is now considered to be a profile of UML expressed within UML's Model Driven Architecture (MDA) (Object Management Group, 2010) specification. However, whilst the name and graphical style may have changed, the underlying process and semantic meaning of the notation have not. 
A Thinking Tool
The choice of systems modelling was guided by a wish to describe abstract behaviour, not by a wish to design and implement large computer programs (although this is a logical follow-on to the research). It was therefore necessary to consider which notational elements of the selected method would be of most use in describing free-standing abstract models and concepts.
Shlaer-Mellor is a powerful tool in this respect as it focuses on expressing information, rather than program structure, with its main diagram, the Information Model (IM) targeted at expressing association relationships. That is to say, more "House is mortgaged to bank", than, "House is composed of four walls, a roof, doors, and windows". Both can be expressed within the notation, but the former is encouraged. It is this focus on describing application-level problem domains that both distinguish it from its predecessor methods such as Jackson Structured Programming (Jackson, 1975) and Yourdon Structured Analysis and Design (Yourdon, 1989), and make it a useful tool in expressing organization of information.
Confidence in choosing the method also comes from Shlaer and Mellor's own intentions for their method: 
Moving up a level, we can say that an information model is a thinking tool used to aid the formalization of knowledge. It helps us to work out how we want to think about a problem: the terms we need to define, the assumptions we make in selecting those terms, and the consistency of our definitions and assumptions.  (Shlaer & Mellor, 1988, p. 7). 
In addition to a single Information Model, the method also explicitly supports organization of large Information Models, allowing them to be expressed as smaller subsystems using the Subsystem Relationship Model (SRM). Considering the complexity of human physiology, and the potential size and complexity of user interfaces and the content that they express, this provided an added potential advantage for the Shlaer-Mellor route.
Independent Problem Domains
As with Aspect Oriented Modelling (Kindler and Schmelter, 2008) which in many ways shadows Shlaer and Mellor's own ideas, the Shlaer-Mellor method views systems as a collection of independent, but related problem domains. In Shlaer-Mellor the relationships between problem domains are expressed by "bridges", whilst in Aspect Oriented Modelling they are expressed by "join points". This idea of related problem domains mapped easily to the concept of an encounter between capability and capacity being expressed as independent, yet related ontologies.
With Shlaer-Mellor, each problem domain is expressed either by a single Information Model, or a collection of related Information Models with each representing one subsystem of the whole domain. The formal definition of a problem domain in this context is:
A domain is a separate real, hypothetical, or abstract world inhabited by a distinct set of objects that behave according to rules and policies characteristic of the domain.  (Shlaer and Mellor, 1992, p133). 
Shlaer and Mellor's definition of a domain is an an almost perfect match for the ontologies surrounding the encounter between user and entity. The definition also raises interesting comparisons with the general concept of an intelligent agent acting on behalf of a user within a given problem domain, which in itself suggested one potential modelling approach.
Shlaer and Mellor's approach to describing the relationships between domains using bridges is more problematic. A client/server hierarchical structure is imposed by the method upon domains to create a hierarchy of problem domains, with an abstract application model at the top requiring the services of (generally) more concrete domains, which themselves may require the services of even more concrete domains. A practical commercial example from Ascom AG Switzerland in the mid 1990s, is a telephone exchange application domain that depended upon a routing domain (to route calls)  and a numbering plan domain (to identify users and potential trunk routes, both of which in turn depended on an event logging/call charging domain and a communications protocol domain; the communications protocol domain in turn, depended upon a device input/output domain, and so on.  Certainly at the outset of this research, no such hierarchy was apparent, rather there were relationships between "peer" ontologies, and it was these "peer" relationships that were considered to express the encounter between user and entity.
A Shlaer-Mellor bridge is composed of a number of elements that express the dependency between two related domains: 
a)	Object counterparts.
b)	Event counterparts.
c)	Change over time.
Descriptions of items (a) and (b) may be found in Shlaer & Mellor (1992) , item (c) comes from personal commercial experience with the method, where it was found on commercial projects that describing the dependencies between domains could only be effectively achieved through expression as sequences of interactions traversing the domain boundaries.
In terms of this research, it was item (a) that was considered important. A counterpart is some entity or object in A that has some equivalence in B; it may not be a direct equivalence, or be a direct one-to-one match. For example, again in a telephone exchange, a telephone number recorded in a phone book may be reached by many different physical routes depending upon time of day and the current network load.
As a second example, using mobile phones, the indication of an incoming text message may be represented visually, audibly, and haptically (through vibration); even the visual representation may have multiple simultaneous forms, for example a flashing icon on the screen, and a change in the message count for the in-box. Depending upon the selection of problem domains to represent the phone, counterpart mapping may involve bridges between multiple domains, for example domains representing different human senses. So, with this in mind, the principle of counterparting was retained, but the hierarchy of domains constructed upon it was removed from consideration. 
The decision to concentrate on counterparting rather than domain dependency was reinforced by a short on-line, non-peer reviewed, paper from Stephen Mellor where he considered the relationship between the Shlaer-Mellor method and Aspect Oriented Modelling (Mellor, 2004). The relevant diagram is reproduced as Figure 1.1 showing the relationship between join points and categories of counterparts. It is this  emphasis given by Mellor to bridges and join points that reinforced the the idea that counterpart mapping is a natural and common aspect to describing complex systems; organizing such mappings hierarchically is only one expression of their use.
Figure 1.1: Relationship between bridges and joint points

Abstract User Interfaces
The Shlaer-Mellor method makes direct reference to user interfaces, and proposes use of an abstract user interface within an appropriate ontology. Counterparts are then identified between client domains and the user interface. For example, a mobile telephone generally requires a user-edited (but not created) phone/address book, which itself requires some form of user interface. In Shlaer Mellor this is drawn as a Domain Chart (DC) as shown in Figure 1.2
Figure 1.2: Simple Shlaer-Mellor Domain Chart
Figure 1.2 shows three related ontologies; an application domain expressing users accessing contact details,  an address book domain expressing the organization of contact details,  and a user interface domain expressing perhaps text, icons and radio buttons. The bridge between the address book domain and the user interface domain describes the mapping of icons to photos and text to data fields, and so on. Such a bridge is an explicit concrete reification of the encounter between a user and a mobile phone. 
Of interest to this research is why those mapping are chosen in the general case. The fact that the Shlaer-Mellor method already considers and expresses specific concrete cases further supported the selection of the method.
Competition for Resources
The view taken at the beginning of this research into user interfaces on mobile devices, was one of competition for scarce resources between individual components of the interface. An example of such competition is the use of audio channels: If the user is in a voice call, and a new text message arrives, does the "new message" ear-con play out? What if the user is recording a voice note?
Shlaer-Mellor explicitly considers such competitive cases in terms of competition to formalize relationships, and consequently allows relationships themselves to be described in terms of assigner state models, similar to the finite state machines which most object-oriented analysis and design methods such as the Unified Modelling Language (UML) , and including Shlaer-Mellor, use to describe behaviour in objects. In comparison, the industry standard use UML has no such explicit consideration of competition.
The Shlaer-Mellor approach with assigner state models is to allow relationships, in addition to objects, to have a lifecycle. Unlike objects, where instances of objects have state models, it is the concept of a relationship manager between objects that has the state model. There is a maximum of one instance of an assigner state model for any named association on an Information Model. Experience has shown this to be a very powerful technique.
Transcoding of Sequences
The hope in describing the encounter between an entity and its users in terms of the relationships between capacity and capability was that those relationships could be populated on a case-by-case basis depending upon the current user of the interface.
Related to this, were the concepts of augmentation and adaptation typical in current commercial assistive technology, exemplified by screen reading software such as Freedom Scientific Inc.'s Jaws for Windows application (Freedom Scientific Inc., 2010). Such existing assistive technology adapts default interaction modalities to match user need, often moving or augmenting presentation between the visual and sonic design spaces. Jaws for example, attempt to present the Microsoft Windows user interface in audio form.
In moving, and in particular, in augmenting presentation of content between design spaces, timing and general sequencing issues arise. For example if visual indication of "new message arrived" on a mobile phone is augmented with an ear-con, what happens if the user acknowledges the indication before play out of the ear-con completes?
A further, more complex, example would be if a higher priority audible becomes required, such as "Incoming call"; this is an example of augmentation increasing the competition for severely limited resources. Selection of Shlaer-Mellor allowed this transcoding-in-a-competitive-environment problem to be considered through the use of assigner state models within domains, and within the bridges between domains. 
Sequence transcoding may also be supported through the use of role migration within information models (discussed below).
Role Migration
In object oriented analysis there are a number of different categories of object. For Shlaer-Mellor, these are listed as: tangible things, roles played, incidents, interactions, and specifications (Shlaer & Mellor 1988, pp 15-16). Abstracting from the tangible user or entity, to roles played by them poses some interesting modelling problems, one example of which is the robot.
A (tangible) robot may play different roles at different times. It may be a working robot, a faulty robot, and a robot under repair. The behaviour of the robot in each case is necessarily different; a faulty robot for example needs to be placed in a safe (off) mode until repaired, whilst when in repair mode it may need to perform certain actions without its safety guards in place. Rather than describing all of that behaviour within a single complex object lifecycle, Shlaer-Mellor uses subtyping to describe three separate objects as shown below.
Figure 1.3: Example of subtype migration
Shlaer-Mellor's subtyping is superficially similar to the inheritance concept found in other object-oriented approaches, but is more restrictive in its definition and significantly different in its approach to dynamic behaviour. The inheritance relationship, signified by the short horizontal line, is "disjoint, complete", which is to say that there cannot be a robot that is not one of Working Robot, Faulty Robot, or Robot Under Repair, and it is never just a "Robot". In terms of object oriented programming, this would mean that all classes are "abstract" except for leaf classes.
This "disjoint, complete" definition of subtyping is related to Shlaer and Mellor's approach to dynamic behaviour, for example where the robot may migrate through various subtypes but remains essentially the same robot and retains the same identity. This is important for the relationships that exist between the robot and other objects in the Information Model; if the robot's identity changed as it migrated, then its relationships to other objects would become invalid because any reference to the robot would now reference the wrong robot. This is unusual in terms of object oriented modelling and programming where to change from "working" to "faulty" would cause a completely new instance of Faulty Robot to be created, common attributes to be copied, and all references to the Working Robot to be replaced. That is to say, the concept of subtype migration is unique to Shlaer-Mellor.
Whilst subtype migration and associated "disjoint, complete" formalism may be unique to Shlaer-Mellor, fro this research it was considered of particular help in dealing with the transcoding of sequences.
The first simple case considered was where a particular user interaction may be undertaken by a number of different protocols, such as notifying the user of an incoming text message. A protocol in this case being a sequence of interactions between the user and the interface. Three potential protocols were identified: 
a) 	Simple notification with no impact on user interaction. An ear-con is a concrete example.
b)	Notification that blocks interaction for a given timeout period. A full-screen modal window on a mobile phone is a concrete example.
 c)	Notification requiring positive acknowledgement by the user. A user-terminated ear-con is a concrete example.
A notification protocol can be considered to be an example of an incident object, and in this case has three subtypes. Which notification subtype is appropriate will depend upon both the character of the content to which it relates, and to the needs and preferences of the user; therefore there are potential counterparts bridging between abstract notifications to a user in a content ontology, and interaction modalities in a "metaphor" ontology. Depending upon the user, and guided by the content, the same notification may be configured to be any one of the three subtypes.
A second, more complex, case considered was that of augmenting a single notification with additional notifications using different design spaces, to support user need. In this case it is not the simple selection of alternative notification protocols, but rather the impact of the additional notification protocol on an existing user interface that needs to be addressed. In particular, it is the potential competition for scarce resources that is of interest, for example the impact of adding additional ear-cons to a busy audio channel on a mobile phone. In this case, the lifecycle of the notification may be described in terms of migrating subtypes as shown in Figure 1.4.
Figure 1.4: Notification migration using migrating subtypes

This shows the lifecycle of a notification broken down into three states, each represented by a subtype of "Notification": Announcing, Dwelling, and Expiring, with the notification beginning in Announcing and ending in Expiring. A similar lifecycle can be expressed as Shlaer-Mellor State Model as shown in Figure 1.5.
The lifecycle shown in Figure 1.5 perfectly describes the supertype "Notification" object shown in Figure 1.4. The protocol of the Announcement, Dwell, and Expiry phases of the lifecycle belong to the appropriate subtypes, as do attributes of the notification related specifically to particular phases, and is specific to each of the three protocols identified in the Notification object.
Assuming that the default notification to be augmented is represented by one of those protocols, the result of augmentation would be two contemporaneously executing protocols whose three phases must be synchronized. Using Shlaer-Mellor, this can be expressed as shown in Figure 1.6.
Figure 1.6 shows a "Notification" object subtyped into three migrating phases of Announcing, Dwelling, and Expiring, each of which awaits a "Rendezvous" before moving the state model of "Notification" into the next state, and migrating to the next subtype. That rendezvous represents synchronization between, in this case, two contemporaneous protocols such as a visual and an audio representation of an "Incoming text message" notification on a mobile phone. The concept of a notification itself has been split between the abstract idea of "Incoming text message", and the visual and audio renderings of the notification, each of which is of a particular protocol type. This ensures that additional contemporaneous notifications are synchronized and that the logical flow of user interaction is maintained, but it does not, as it stands, address competition for resources between notifications in the same phase. Such resolution in Shlaer-Mellor requires additional assigner state models (discussed earlier), with one possible solution shown in Figure 1.7 
Figure 1.5: Notification lifecycle as state model
Figure 1.6: Multiple contemporaneous notification protocols
Figure 1.7 extends the contemporaneous notification example to show the relationship between a "Notification" and the resources needed to express it when rendered; it is this mapping that requires an assigner state model to resolve competition issues. Such assignment would typically be triggered by the formalization of rendezvous relationships, allowing for an appropriate competition algorithm to be applied, and if necessary, deadlock detection or avoidance to be implemented. In practice, synchronization may be a prioritization policy, or a queuing mechanism, or both. In terms of this research, the expectation was that such assigners would represent actors involved in self-adaptation of content and modalities to match user need.
The two example cases only consider the impact of contemporaneous "Notifications" upon each other and upon potential bridges between content and modality. A more comprehensive consideration of competition for resources and associated synchronization issues was expected to form part of the research. However, even the limited cases considered here suggest that taken together  bridging; assigner state models; and role migration; all of which are unique to Shlaer-Mellor, were appropriate tools to investigate and model the competition for, and allocation of, resources within an adaptive user interface.
Figure 1.7: Multiple contemporaneous notifications with competition resolution
N-ary Relationships
Consideration of competition for resources, and of issues relating to the sequencing of content for presentation raised the possibility of N-ary relationships.
An N-ary relationship in this context is an association between three or more objects. The example case postulated was a description of the factors surrounding the selection of appropriate interaction modalities from a user's profile. How would one express that the selection process was based on, say, consideration of content characteristics, user capability, device capacity, environmental concerns, and, custom and practice for mobile phone user interface design?
Given that the needs of each category may conflict, and that the physical capacity of the device to express content and receive input may require sequencing, the natural first step in describing the problem is an N-ary relationship to express the associations, and an assigner state model to express conflict resolution and sequencing. This is supported by the Shlaer-Mellor method using a correlation table as shown in Figure 1.8. This is redrawn from Shlaer and Mellor (1988) p. 74, but with an Assigner State Model associated with the relationship.
Figure 1.8: N-ary Relationships - redrawn from Shlaer and Mellor (1988) 
Shlaer and Mellor admit to having found no convincing example in practice for the use of N-ary relationships, and discontinued the use of correlation tables in their 1992 volume. Personal experience since 1989 with the method confirms a lack of practical examples. It must be said however, that no commercial modelling tools in the 1990s for Shlaer Mellor, notably Object Team, BridgePoint, and Intelligent OOA provided effective support for  N-ary relationships, which perhaps coloured perception somewhat on those projects. When creating new Information Models on commercial projects, N-ary relationships were commonly identified, before refinement into a collection of "better" binary relationships in the formal models. Given that the choice of Shlaer-Mellor for this research was to support the thinking process rather than constructing efficient computer programs, N-ary relationships appeared a reasonable choice for inclusion in the selected semantics.
Rule-based Systems
One of the expected areas of concern in this research was how an expected encounter between user and entity affected the construction of the interface between them. In simple terms, how can a user's physical and cognitive capabilities be compared with an entity's capacity to support them for a given context?
The (dynamic) decision making process within Shlaer-Mellor revolves around the lifecycles of objects which are described in terms of Moore state models (Shlaer & Mellor, 1992, pp 33-66)[x[. Moore state models are interesting in that they allow some internal decision logic about state transitions to be expressed directly in the state model diagram by use of internal transient states traversed by internally generated events.
Shlaer-Mellor go further, considering the actions on entering a state to be formalized into Action Data Flow Diagrams (ADFDs) that further refine the decision making process. Personal experience of commercial projects using Shlaer-Mellor is that ADFDs are unmanageable and actually obfuscated rather than illuminated the actions they were describing, and consequently were never used. In each case ADFDs were replaced with structured English descriptions, or in the case of Ascom AG in Switzerland, in a constrained version of an interpreted programming language called Tcl/Tk (Newman 2004), which allowed the analysis models to be directly executed under simulation. Both approaches meant that decision logic within a state was described using simple "IF a THEN b ELSE c" constructs, with instance selection based on Structured Query Language (SQL) (International Standards Office, 2007).
A set-based approach was, and in UML form still is, provided by one of the main tool vendors for the Shlaer-Mellor method, Kennedy Carter Ltd whose Action Specification Language (Kennedy Carter Inc., 2006)]  emulates key aspects of SQL. An extract of syntax from their UML version (their Shlaer-Mellor documentation is withdrawn from circulation), repeated from Wilkie, is shown below.
<instance handle> = find-one <class> <instance handle> = find-one <class> where <condition> <instance handle> = find-one {<set of instance handles>}
{<new set>} = find-all <class> {<new set>} = find-all <class> where <condition> {<new set>} = find-all <class> {<set of instance handles>}
{<new set>} = union-of {<old set a>} and {<old set b>} {<new set>} = disunion-of {<old set a>} and {<old set b>} {<new set>} = intersection-of {<old set a>} and {<old set b>}
{<new set>} = {<old set a>} not-in {<old set b>} 
The (static) decision making process within Shlaer-Mellor is inherent in the object associations represented by an Information Model. An Information Model is a collection of objects connected to, and navigated by, relationships. As such, an Information Model is one realization of a directed graph with the objects representing nodes and the relationships representing edges. Consequently, any decision or rule-based system capable of expression in the form of a directed graph is expressible within an Information Model, although it is typically expressed in meta-form with the rules described by population tables. For example, a simple decision tree may be expressed as shown in Figure 1.9.
Even the simple model shown in Figure 1.9  is sufficient to describe real-world problems. A practical example from a real project, is subscriber identification in a telephone exchange as numbers are dialled from a phone. This forms an interesting example in terms of accessibility research as the search for subscriber identification in some ways parallels the auto-complete functions now commonly  found on websites such as Google (Google Inc., 2010). Such auto-complete modalities  cause significant problems for existing assistive technology, with Jaws for Windows for example, mute during updates to the auto-complete options.
The mapping of telephone numbers to subscribers and trunk lines in a telephone exchange is shown in Figure 1.10 with example population tables shown in Table 1,Table 2, and Table 3 for local subscriber numbers 201 and 202, and trunk route 01642. 
Figure 1.9: Decision tree representation in Shlaer-Mellor
Figure 1.10: A telephone numbering plan expressed as a Shlaer-Mellor decision Tree

Table 1: Population Table for object Digit Node
Node Id
Digit
Node Type
1
2
PLAIN 
2
0
PLAIN
3
1
LOCAL 
4
2
LOCAL
5
0
PLAIN
6
1
PLAIN
7
6
PLAIN
8
4
PLAIN
9
2
TRUNK
The meta-model approach to describing rules, for example the numbering plan decision tree above, populated with specific instances, was the intended approach to models for this research, so that user capability, device capacity, operating context, and the static rules for resolving this N-ary relationship would form a single Shlaer-Mellor multi-domain model. It was to be this populated model that would describe the encounter between user and entity.
The description of how those rules are to be applied at run-time in order to construct a user interface would naturally fall upon the state model/assigner state model, and state actions described earlier; however, even here, experience acquired during this research suggested that such finite state modelling and associated state actions should also be considered in the static form. The basis of this argument is related to  the problem of describing where, exactly, in a model of user interaction counterpart variations can occur to support user need. The replacement of a single block of content with another represents a relatively simple identification of span within the overall encounter between user and entity.
Table 2: Population table for branch object
Parent Node Id
Child Node Id
1
2
2
3
2
4
5
6
6
7
7
8
8
9

Table 3: Population table for Numbering Plan object
Id
Node Id
1
1
2
5
Modification of dynamic behaviour, for example insertion of additional ear-cons in a user interface, requires a much more precise identification of the affected span. Describing that dynamic behaviour through a Shlaer-Mellor Information Model would allow for such a level of granularity in tagging spans of behaviour. Shlaer-Mellor notation was considered to be appropriate for this task:
   a)	As finite state machines are themselves a realization of a directed graph, with states representing nodes and events representing edges, then the state models themselves can be expressed by a meta-model of a state machine and an instance table.
   b)	As an algorithm can be considered a realization of a directed graph of nested sequences of elemental actions terminated by a decision point, with "actions + decision point" representing nodes, and the mapping between current node and target nodes representing edges, then state actions can be expressed by a meta-model of procedural languages and an instance table.
Taking this approach to expressing the dynamic component of an encounter between user and entity also allows for portable user profiles to express preferred adaptations to dynamic behaviour independently of both specific programming languages and operating systems, significantly improving the potential usefulness of such profiles.
Adaptivity
A user interface may adapt to match user need and preference in one of two ways. It may adapt either statically through an initial configuration based on pre-selected options, or dynamically in response to external events during operation.
It was particularly the dynamic aspect of adaptation that was considered in selection of a notation, as data-driven object models such as those of Figure 1.10 and its associated population tables are relatively well understood. Dynamic adaptation itself breaks down into two categories, namely rule-based exception handling, and learnt behaviour.
Exception handling within a user interface further sub-divides between internal design and implementation errors, and communication failures between the user interface and external entities such as between a web page and a web server. Shlaer-Mellor supports both cases with a dual view of State Models, with the traditional graphical representation of a Moore State Model supplemented by the more comprehensive state transition table (Shlaer-Mellor, 1992, section 3.6). In terms of selection of notation, this also differentiates Shlaer-Mellor from UML where exception handling is encompassed within its Object Constraint Language (OCL). On inspection, and based on previous commercial experience, the duality of state model and state transition table representations, at least when supported by appropriate modelling tools, appeared to provide the best encapsulated state model behaviour.
A state transition table describes the effect of every possible event targeted at a particular state model whilst the model is in each possible state, with "Can't Happen" and "Ignore" as additional possible values; this allows for a general exception handling policy to be identified. Such a policy is important in terms of accessibility, as the impact of exception handling on a disabled user may be significant.  One simple example would be an exception occurring when a user has selected a deeply nested menu option; if navigation depends upon screen reading technology or other highly sequential presentation techniques such as scanning, the strategy for notification and handling of the exception can have significant impact on usability, and on cognitive load in terms of understanding the resultant forced navigation.
The expectation was that use of State Transition Tables for general exception handling within this research, would allow for user capability to drive adaptations of the "Can't Happen" and "Ignore" entries within the tables.
Consideration of learnt behaviour revolves around the concept of an entity monitoring user performance whilst interacting with that user in order to optimise the delivered interface. Microsoft Corp.'s hiding of unused icons in Windows XP, and the "paper clip" avatar in Microsoft Word which suggests to the user improved ways to use the application, are examples of this approach. For this research, the use-case post was the concept of monitoring key presses, looking at the time taken, and the success rate, to choose multi-key presses, for example using the shift key for capitalization. Depending upon the success rate, the user would be offered the option to enable "sticky keys" where multi-key presses are serialized so that "SHIFT-A" on the keyboard for example, becomes "SHIFT" then "A".
Describing such a system in Shlaer-Mellor would naturally fall into expressions of rule-based systems as described in Section 1.3.10. At the more detailed State-Model level, adaptation could also be expressed by changes to the “Ignore” entries in State Transition Tables to monitor for non-printable key codes such as “CTRL”, “ALT”, and “SHIFT”, and this was the expectation for this research.
Adapting the Shlaer-Mellor OOA Process 
The Shlaer-Mellor method of Object Oriented Analysis and Design is composed of a notation and a software development process based on the concept of translating a precise OOA analysis model directly to a computer program. This section describes specifically the Shlaer-Mellor process and how it may be adapted to support this research into the encounter between user and entity, rather than for its original purpose of general software construction.
Domains and Domain Hierarchy
One of Shlaer-Mellor's arguments for the use of problem domains is project organization. With large projects separated into discrete subject areas (domains) it becomes easier to match subject matter experts to particular domain models, and to reduce interdependence between subject area teams. In a small, single researcher project such as this Ph.D., efficient team organization is irrelevant, but a separation of concerns is still helpful in structuring the work.
Shlaer-Mellor also address the order of work on multiple domain projects, relating the method to the classic waterfall development methods still prevalent today, and provide a complete mapping to US military development standard DOD-STD-2167A (cited in Shlaer & Mellor, 1992, appendix B). In summary, their approach is to recommend that if a waterfall strategy is required, then to order the modelling of domains from top to bottom of the domain chart, following the principle that the upper domains specify the requirements for the lower domains.
At the beginning of this research there was no obvious domain hierarchy to apply; rather there was an intention to consider domains a peers rather than clients and servers. However, over the period of the research, a natural order to domain modelling emerged, considering first the user, then the device and environment, and finally an abstract view of content; each stepping logically further away from the user (and also informs the chapter order of this thesis). This has a clear parallel with the Shlaer-Mellor approach, where tat he domain chart apex sits  a view of the application to be modelled, with lower level domains providing services generally closer and closer to the hardware the resultant computer program will run upon.
Implementation by Translation
One of the main distinguishing features of the Shlaer-Mellor method at its introduction between 1988 and 1992 was their approach to design and implementation of analysis models. The prevailing view of the earlier structured analysis and design methods, including Stephen Mellor's own contribution, Ward-Mellor (Ward and Mellor, 1986), was that one begins with a requirements analysis which is then elaborated with hardware architecture details, which in turn is elaborated with software architecture details, which is then elaborated with detailed input/output details, and so on. The result was a functional decomposition of a problem from the “drive a train” level of requirement, down to “braking task applies brakes for three seconds by raising bit 3 of port 32 on microprocessor 2”. 
Shlaer and Mellor still provided decomposition, but as semantic decomposition through their domain hierarchy, and largely independent of architectural issues. Rather than hard-coding the choice of number of microprocessors, number of operating system processes, and particular communications protocols directly into the design, Shlaer-Mellor considers their Information Models and state models as executable meta-models, and describes a series of rules on how an instance of an object, its attributes, its relationships, and its state model should be coded in a particular programming language for a particular architecture. This they termed, recursive design (Shlaer and Mellor, 1997).
Recursive design provides a rule-based mapping from a requirements model directly into a computer program, and that rule set is described as an archetype; the process of creating and applying an archetype is  considered to be translationist, as opposed to elaborationist. The train control example, in Shlaer-Mellor, be comes an application domain at the level of "drive a train", with perhaps a service domain of "Braking System", and an implementation domain "I/O" that is specific to the chosen hardware architecture. Recursive design then applies archetype rules to each domain, and to the bridges between the domains to create the final program, so the choice of processor 2, and allocating into concurrent "tasks" is made by archetype rules, independently of the domain models.
Close cousins of recursive design are the principles behind abstract user interfaces, where a single model of user interaction for particular content is described first in general and abstract terms, and later rendered to the user according to reification rules that describe the required look and feel for a specific computer architecture or software platform; Web mark-up notations such as the Hypertext Markup Language (HTML) are one example, and are considered later in this thesis.
Shlaer-Mellor goes as far as to show the user interface as service domain of an application, and a client of an operating system domain within an example Domain Chart (Shlaer & Mellor, 1992, fig. 7.4.1, p. 141). On inspection, the rule-based mapping by archetype, utilized in recursive design, was considered to be a potential framework for describing the kind of adaptations of user interaction generally associated with assistive technology; it was this framework that became the basis for describing the encounter between user and entity, with that encounter described as a kind of meta-model of the Shlaer-Mellor recursive design process.
Whilst considering a meta-model of the recursive design process as a framework to describe the encounter between user and entity, recursive design was also considered in its own right as a means of validating the generated models. The ability to generate and/or directly execute individual domains, or groups of domains, is one of the key selling points for Shlaer-Mellor, and for Model Driven Architectures in general. In this approach, scenarios, or more formally use-cases, are developed as test cases to stress test domains, or groups of domains; the domain(s) is then either simulated within a Computer Aided Software Engineering (CASE) tool such as Intelligent OOA (a commercial product from Kennedy Carter Ltd in the 1990s) or executed in the target environment after generation through the recursive design process. In practice, simulation is one realization of a recursive design archetype for the given simulation environment. This was the approach taken at Ascom AG for example, in a telephone exchange project, using an in-house created simulator and automated test tools. 
Such an approach does not, generally, provide comprehensive test coverage simply because comprehensive, exhaustive test coverage of complex systems is impractical. Consider a simple pseudo-code fragment, which has three active lines of code:
if (A or B or C) then 	do X else 	do Y end if
One simple measure of test coverage would be: is every active line executed by the tests? For this example, that requires two tests, one for the test clause being TRUE, and one for it being FALSE. However, there are three variables in the test clause, A, B, and C, so a more comprehensive test would be: is every combination of A, B, and C that may generate a TRUE result covered by the test, in addition to the FALSE result? That requires seven tests, not two. It can be argued that only four tests are required since many programming language compilers will short-circuit such a test, so that if A is true, then B and C are not evaluated, so that the number of test may actually be only four, however evaluating condition B or condition C may cause programming side effects (which does happen); hence the safe number of total tests for full coverage without knowledge of the compiler design is eight. That is eight tests for one small fragment of code. When the complexity of cooperating object state models is considered, the number of test cases becomes unmanageable, hence the reliance on stress testing through use-cases.
Such stress testing may still provide some simple coverage metrics, for example the state transition testing strategy outlined in the British Standard for Component Testing (British Standards Institution, 1998) describes testing of state models in terms of coverage of events between states within a single model:
“For single transitions, the coverage metric is the percentage of all valid transitions exercised during test. This is known as 0-switch coverage. For n transitions, the coverage measure is the percentage of all valid sequences of n transitions exercised during test. This is known as (n - 1) switch coverage.”  (British Standards Institution, 1998, section 4.3)
A systems analysis approach to defining accessibility was selected for this research in part because of the difficulties in defining the breadth of user capability in a usable and verifiable form, yet the preceding discussion on testing and verifying analysis models demonstrates a similar problem. There is however, a distinct difference in the character of the problems faced by the two strategies:
a)	With the original approach described in Methodology Selection in Section 1.1, the system under validation was an explicit model of capability, capacity, operating context, and content. It is the specific models that are tested for fidelity.
b)	With the new systems approach based on the meta-model of recursive design, the system under validation is the underlying model of how representations of capability, capacity, operating context, and content, interact during the process of reification through recursive design. It is the representation of the recursive design process that is tested for fidelity.
The advantage of the systems approach is that the accuracy and level of detail of the content held in the capability, capacity, operating context, and content models do not significantly impinge upon the test results and evaluation so long as the detail is representative of that content. This means that specialist detailed knowledge of vision, hearing, mobility, and cognition was unnecessary in order for the research to progress.
Archetypes
The Shlaer-Mellor recursive design method to translate object oriented analysis models directly into computer programs relies in the concept of archetypes and archetype diagrams:
“Instead we suggest that you produce class diagrams and class structure charts  in detail only as archetype diagrams – diagrams that indicate where specialization must be accomplished by name substitution. These diagrams, together with the rules for making name substitutions, amount to a specification of the architecture.” (Shlaer and Mellor, 1992, pp. 192-193).
This concept of rule-based adaptation, a forerunner of UML's Model Driven Architecture  (Object Management Group, 2010) approach, has parallels with the approach taken both when reifying abstract user interfaces, and when adapting concrete user interfaces to match the needs of disabled users. In the former case, content is mapped to elements of generically defined interaction modalities. In the latter case,  semantic equivalence between interaction modalities is mapped. The problems encountered by existing assistive technology when mapping semantic equivalence, for example inferring meaning from an HTML scripted Web page, was highlighted early in this research, and the hope was that a detailed investigation of recursive design would shed new light, and potential solutions, on this area.
Related to the problem of mapping semantic equivalence, is the expression of “accessibility layers” in both user interfaces and user-interface centric programming languages such as Java (Oracle Inc., 2010). Superficially at least, there seemed a degree of commonality between the characterization of a system and the definition of conceptual entities found in recursive design (Shlaer and Mellor, 1997, pp. 63-67), and the expression of content in a user interface to assistive technology through “accessibility layers” such as Microsoft Windows (Microsoft Corp. 2010), or the Java programming language. Again, some consideration of, and comparison between, recursive design and existing “accessibility layers” was expected to form part of the research.
Summary
The original goal of this research was to look at ways to improve the accessibility of hand-held mobile devices to disabled people.  Such a goal immediately raises the questions of:
a)	 Who, exactly. will benefit from the work.
b)	What problems, precisely, are  to be solved. 
With a preferred answer to the first question as “everyone”,  the complexity of human physiology and its variations in capability, becomes a significant problem in its own right.
Having inspected a number of approaches to resolving  accessibility problems in existing user interfaces,  it became clear that one had to step back from the specifics of individual solutions, and to concentrate effort on what it is that allows user interfaces to be constructed to match user need. To that end, the research took a systems modelling view of the problem, and adopted the Shlaer-Mellor approach to object oriented analysis.
The chosen systems approach divided the problem into five semantically independent subject areas, namely: users; devices; context; content; and adaptation. Each of these areas was then considered in its own right, and in relation to each other with the intention of creating meta-model of the process of interface adaptation.
In choosing specifically the Shlaer-Mellor method for this work, detailed consideration was given to the expected problems associated with expression of adaptation in general, and user interfaces in particular. This consideration was informed by personal professional experience both with the Shlaer-Mellor method, and with user interface design methods in the telecommunications industry over a fifteen year period.
Conclusion
From review of existing accessibility literature, it would appear that the general  approach taken here is relatively unique in considering accessibility in broad abstract terms of an encounter between user and entity. 
Narrower consideration within each of the chosen subject areas of: users, devices, context, content, and adaptation does exist elsewhere,  including the use of object oriented analysis and related notations to express that work; these are discussed in context in later chapters.  For example, one of the key papers supporting this research is Nesbitt's work on the  multi-sensory design space (Nesbitt, 2001)  which is couched in terms of UML notation.  To that extent this systems methodology approach lies within an existing  and accepted research approach to systems-related problems, if not directly accessibility related problems.
What is genuinely unique, and a contribution to knowledge, is the detailed consideration of the Shlaer-Mellor object oriented analysis and design method to accessibility in general, and to the expression of adaptable/adaptive user interfaces in particular. This chapter details the particular elements of both Shlaer-Mellor semantics, and Shlaer-Mellor process that appear to support the investigation and construction of problems and interfaces. The more unique aspects of Shlaer and Mellor's approach are highlighted showing how, for example, semantic decomposition into problem domains, and state transition tables help illuminate the decision points around which adaptation and augmentation of a user interface to match use need occur.
 The structure of this methodology chapter is perhaps a little different to that one would expect of, say, a heavily experimental accessibility related Ph.D. Involving design and user testing.  To some extent, it follows the dramatic conceit of the “play-within-a-play”, in that the the methodology chosen, object oriented analysis and design of a problem, is then analysed in detail to identify which aspects of the particular method are likely to be appropriate to the study of accessibility as an encounter between user and entity. In doing so, the methodology is, in a sense, applied to the methodology; an object orientated analysis of an object oriented analysis.
References
British Standards Institution, 1998. BS 7925-2:1998 Software testing. Software component testing. Milton Keynes: BSI.
Freedom Scientific Inc., 2010 product catalogue [Online]. Available at: http://www.freedomscientific.com/products/fs/jaws-product-page.asp [Accessed: 6 February 2010].
Fuentes, L. and Sánchez, P. 2007. Towards executable aspect-oriented UML models. In Proceedings of the 10th international Workshop on Aspect-Oriented Modeling pp. 28-34. Vancouver, Canada. New York, NY: ACM Press.
Google Inc., 2010. Google search page [Online]. Available at: http://www.google.com/ [Accessed: 6 February 2010].
Hall, C. A. 2009. Web presentation layer bootstrapping for accessibility and performance. In Proceedings of the 2009 international Cross-Disciplinary Conference on Web Accessibility (W4a) pp. 67-74. Madrid, Spain. New York, NY: ACM Press. 
International Standards Office, 2007. ISO/IEC 13249-1:2007 - Information technology -- Database languages -- SQL multimedia and application packages -- Part 1: Framework. Geneva:ISO.
Jackson, M.A., 1975. Principles of program design. London, United Kingdom: Academic Press.
Kennedy Carter Inc., 2006. The UML Action Specification Language Reference Guide [Online]. Available at: http://www.kc.com/DOWNLOADS/browse.php [Accessed: 6 February 2010].
Kindler, E. and Schmelter, D. 2008. Aspect-oriented modelling from a different angle: modelling domains with aspects. In Proceedings of the 2008 AOSD Workshop on Aspect-Oriented Modeling, p 7-12. Brussels, Belgium, April 01 - 01, 2008.  New York, NY: ACM Press.
Mellor S.J., 2004. A framework for  Aspect Oriented Modelling  [Online]. Available at: http://www.cs.iit.edu/~oaldawud/AOM/AOM2003/Stephen-AOSD.pdf.  [Accessed: 6 February 2010].
Mellor S.J. and Balcer M.J. 2002. Executable UML: a foundation for model-driven architecture. Reading, MA: Addison-Wesley.
Microsoft Corp., 2010.  Accessibility and Global Support [Online]. Available at: http://msdn.microsoft.com/en-us/library/dd371677%28VS.85%29.aspx [Accessed; 6 February 2010].
Nesbitt, K.V., 2001.  Modeling the multi-sensory design space. In Australian Computer Society: Proceedings of the 2001 Asia-Pacific Symposium on information Visualisation - Volume 9 pp.27-36. Sydney, Australia.  Australian Computer Society:  Darlinghurst, Australia.
Newman P.,  2004.TCL standard library specification [Online] Available at: http://wiki.tcl.tk/11299 [Accessed: 6 February 2010].
Object Management Group 2010. MDA Specifications [online]. Available at: http://www.omg.org/mda/specs.htm [Accessed: 3 February 2010].
Oracle Inc. 2010. The Java language specification, third edition [Online]. Available at: http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html [Accessed: 6 February 2010]
Raistrick C. et al 2004. Model Driven Architecture with Executable UML. Cambridge, United Kingdom: Cambridge University Press.
Ramloll, R. and Brewster, S.A. (2002) A generic approach for augmenting tactile diagrams with spatial non-speech sounds. In: Conference on Human Factors in Computing Systems, 20-25 April 2002, pp. 770-771, Minneapolis, MN. ACM Press: New York, NY.
Shlaer S. and Mellor S.J. 1988. Object-oriented Systems Analysis – Modeling the World in Data. Englewood Cliffs, New Jersey: Yourdon Press.
Shlaer S. and Mellor S.J. 1992. Object Lifecycles  – Modeling the World in States. Englewood Cliffs, New Jersey: Yourdon Press.
Shlaer S. and Mellor S.J.  1997.  	Recursive design of an application-independent architecture. In IEEE Software volume 14, pp. 61-72. Piscataway, NJ: IEEE.
Starr L. 2002. Executable UML – How to build class models. Upper Saddle River, NJ: Prentice Hall PTR.
Ward P.T. And Mellor S.J., 1986. Structured Development for Real-Time Systems (Vol. 1: Introduction and Tools). Upper Saddle River,  NJ: Prentice Hall PTR.
Yourdon E., 1989. Modern structured analysis. Upper Saddle River,  NJ: Prentice Hall PTR.
